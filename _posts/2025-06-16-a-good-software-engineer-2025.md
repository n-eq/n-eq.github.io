---
layout: post
title: "What does it take to be a good software engineer in 2025?"
date: 2025-06-16 00:00
tags: [engineering, philosophy]
excerpt: "What's a good software engineer in 2025?"
---

With the rise of AI, the never-ending debates about its threats to software engineering jobs,
coupled with tech layoffs[^1], software engineering became an over-saturated market that's
hard to penetrate, especially for juniors.

Lately I've spent some time reflecting on the question of what defines a "good" software engineer, what
really makes the difference between them and the rest?

## What does "good" even mean?

"Good" is a very broad and subjective word that alone fails to capture what the topic I want to
address. While there is no universal definition, a good software engineer is
one that is: 

- Impactful within their team.
- Able to find efficient & performant solutions to the problems they face.
- Able to communicate correctly.
- Able to land a new job easily (perform well at hiring interviews).

That being said, here are the principles I believe every software engineer should be working on
today.

## 0. Thou shalt have a strong online presence

This is arguably one of the best ways to demonstrate your skills: **cultivate your online
presence**. \
In 2025, I strongly tend to think that to be a successful software engineer, typing your name in
Google should yield results that show your work. Whether it's speaking at public conferences,
creating videos, podcasts, writing technical articles, or open-source contributing, you **need** to
stand out by asserting your presence.

However, visibility is not the end goal. It's also not a substitute for competence, but a complement
to it.

Similarly, consistency is key. Regularly creating relevant content in different formats can be
highly helpful in building trust and good reputation within the community.


## 1. Thou shalt master thy stack

A good engineer is one that's able to reinvent the wheel. Because they deeply understand
what they're doing, they're able to explain the concepts and reimplement the tools they use daily,
since they don't treat them as black boxes.

Let's take an example. If you're a full-stack/web developer, try creating a library-free basic
authentication system, implement a basic router for an SPA, build a simple
ORM from scratch to map JS objects to SQL queries, etc. \
If (like me) you're a systems/low-level developer, reimplement any non-trivial C stdlib function,
write an I²C device driver, etc. \
Of course, these are random-ish examples, but I hope you get the
idea. Start small, then scale up to a bigger project like building a miniature clone of a bigger
thing.

Also, this doesn’t mean rejecting existing tools out of pride. The point is to gain insight by
building things yourself, not to replace robust libraries when they do the job, especially in
a professional context.

## 2. Thou shalt wield AI agents/LLMs with wisdom

In 2025, software engineers cannot afford ignoring AI agents and LLMs of all kinds. Although they're
still not fit for all types of software engineering, as an aspiring good engineer, you need to keep
an eye on the recent advances that are applicable to your field. You need to read the literature and
the state of the art of tools that can boost your productivity. \
In my humble point of view, this is still a very crumbly field with a great deal of hype,
uncertainties, and trial-and-errors. As a result, there is no clear method to follow or model to
learn from (no pun intended), you should make your own way into building your efficient workflow to
learn and benefit from AI.

However, there is **one big pitfall** to this: _excessive reliance_. I think the first drawback to
fear from this situation in the long run is what can be called "skill dilution", which goes against
the "deeply understand your stack" point above. \
With this in mind, AI ought to be used as a strategic assistant on steroids, not a magic wand.
Depending on it too much is not only bad because it's often counterproductive, but also because it
can slowly lead to organic thinking atrophy, and affect your problem solving skills, when it comes
short of giving a proper solution to a complex subject.

## 3. Thou shalt keep learning continuously

Unlike other jobs, being a software engineer means staying up to date with an ever-accelerating wave
of innovation. The best programmers are lifelong (and avid) learners. Whether you're working on
personal projects, reading cutting-edge papers, or mentoring others, having (or building) a mindset
of continuous curiosity is one of your best long-term assets.

## A word to end

Becoming a good software engineer is not an overnight process. The market may be tough now, but
those who combine curiosity, practical skills, resilience and adaptability will always have a seat
at the table — no matter how far AI advances.

### Footnotes
[^1]: according to layoffs.fyi, there were more than 150k tech layoffs in 2024, and 61,814 so far this year
